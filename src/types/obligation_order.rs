//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshSerialize;
use borsh::BorshDeserialize;

/// A single obligation order.
/// See [Obligation::orders].
#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ObligationOrder {
/// A threshold value used by the condition (scaled [Fraction]).
/// The exact meaning depends on the specific [Self::condition_type].
/// 
/// Examples:
/// - when `condition_type == 2 (UserLtvBelow)`:
/// then a value of `0.455` here means that the order is active only when the obligation's
/// user LTV is less than `0.455` (i.e. < 45.5%).
/// - when `condition_type == 3 (DebtCollPriceRatioAbove)`:
/// assuming the obligation uses BTC collateral for SOL debt, then a value of `491.3` here
/// means that the order is active only when the BTC-SOL price is greater than `491.3` (i.e.
/// > 491.3 SOL per BTC).
pub condition_threshold_sf: u128,
/// A configuration parameter used by the opportunity (scaled [Fraction]).
/// The exact meaning depends on the specific [Self::opportunity_type].
/// 
/// Examples:
/// - when `opportunity_type == 0 (DeleverageSingleDebtAmount)`:
/// Assuming the obligation uses BTC collateral for SOL debt, then a value of `1_234_000_000`
/// here means that a liquidator may repay up to 1234000000 lamports (i.e. 1.234 SOL) on this
/// obligation.
/// Note: the special value of [Fraction::MAX] is *not* allowed in this case.
/// - when `opportunity_type == 1 (DeleverageAllDebtAmount)`:
/// The only allowed value in this case is [Fraction::MAX] (to emphasize that *all* debt
/// should be repaid).
pub opportunity_parameter_sf: u128,
/// A *minimum* additional fraction of collateral transferred to the liquidator, in bps.
/// 
/// The minimum bonus is applied exactly when the [Self::condition_threshold_sf] is met, and
/// grows linearly towards the [Self::max_execution_bonus_bps].
/// 
/// Example: a value of `50` here means 50bps == 0.5% bonus for an "LTV > 65%" order, when
/// executed precisely at the moment LTV exceeds 65%.
pub min_execution_bonus_bps: u16,
/// A *maximum* additional fraction of collateral transferred to the liquidator, in bps.
/// 
/// The maximum bonus is applied at the relevant "extreme" state of the obligation, i.e.:
/// - for a stop-loss condition, it is a point at which the obligation becomes liquidatable;
/// - for a take-profit condition, it is a point at which obligation has 0% LTV.
/// 
/// In non-extreme states, the actual bonus value is interpolated linearly, starting from
/// [Self::min_execution_bonus_bps] (at the point specified by the order's condition).
/// 
/// Example: a value of `300` here means 300bps == 3.0% bonus for a "debt/coll price > 140"
/// order, when executed at a higher price = 200, at which the obligation's LTV happens to
/// be equal to its liquidation LTV.
pub max_execution_bonus_bps: u16,
/// Serialized [ConditionType].
/// The entire order is void when this is zeroed (i.e. representing [ConditionType::Never]).
/// 
/// Example: a value of `2` here denotes `UserLtvBelow` condition type. Of course, to
/// interpret this condition, we also need to take the [Self::condition_threshold_sf] into
/// account.
pub condition_type: u8,
/// Serialized [OpportunityType].
/// 
/// Example: a value of `0` here denotes `DeleverageSingleDebtAmount` opportunity. Of course, to
/// interpret this opportunity, we also need to take the [Self::opportunity_parameter_sf] into
/// account.
pub opportunity_type: u8,
/// Internal padding.
/// The fields above take up 2+2+1+1 bytes = 48 bits, which means we need 80 bits = 10 bytes to
/// align with `u128`s.
pub padding1: [u8; 10],
/// End padding.
/// The total size of a single instance is 8*u128 = 128 bytes.
pub padding2: [u128; 5],
}


